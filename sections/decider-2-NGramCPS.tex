% !TeX root = ../bbchallenge-paper.tex

\newpage

\newcommand{\alphabet}{\mathcal{A}}
\newcommand{\ngramcps}{NGramCPS\xspace}

\subsection{$n$-gram Closed Position Set (\ngramcps)}\label{sec:n-gramCPS}

The $n$-gram Closed Position Set (\ngramcps) decider which we introduce here is a simplification of an earlier technique, Closed Position Set (CPS), itself introduced in \texttt{bbfind} \cite{Skelet_bbfind}\tsm{This is assuming that the related work section will explain what bbfind is}. Surprisingly, \ngramcps is a relatively simple technique which makes a potent decider, especially when augmenting the binary alphabet of Turing machines to record extra information on the tape, such as a fixed-length history of previously seen (state,symbol) pairs, see Section~\ref{sec:n-gramCPS:augmentations}.

\subsubsection{\ngramcps algorithm}\label{sec:n-gramCPS:algo}

Algorithm~\ref{alg:NGramCPS} gives a pseudo-code of the \ngramcps decider. The decider considers finite, \textit{local configurations} of a Turing machine consisting of: the \textit{$n$-grams} respectively to the left and to the right of the head, the state the machine is in and the middle symbol (currently read by the head). By \textit{$n$-gram}, we mean a sequence of $n > 0$ symbols from the tape alphabet (for instance, the binary alphabet $\alphabet=\{0,1\}$). The algorithm builds a set of local configurations \textit{potentially} reachable by the machine until either an undefined transition is met (Algorithm~\ref{alg:NGramCPS}, l.\ref{alg:NGramCPS:line:unknown}) or no new configurations are added to the set, i.e. the set is closed under Turing machine operations (Algorithm~\ref{alg:NGramCPS}, l.\ref{alg:NGramCPS:line:non-halt}). In the first case, the decider cannot conclude and the machine is left undecided. In the second case, the decider concludes that the machine does not halt as no undefined transition can be reached.

The central idea of this decider and the reason behind using the ``$n$-gram'' terminology (originating from \textit{$n$-gram models} in language analysis)  is better illustrated by the following example. Let $n=3$ and consider local configuration \texttt{011 [B0] 100}, meaning that the left $n$-gram is \texttt{011}, right $n$-gram is \texttt{100}, the machine is in \textcolor{colorB}{B} and reading symbol \texttt{0}. Assume that the  machine's transition for reading a \texttt{0} in state \textcolor{colorB}{B} is \texttt{1RC}, meaning that the machine writes \texttt{1}, moves right and transitions to state \textcolor{colorC}{C}. The local configuration becomes \texttt{011 1 [C1] 00?}, where \texttt{?} means that we don't know which symbol to use. Then:

\begin{enumerate}
    \item \textbf{Left $n$-gram update.} We record the left $n$-gram \texttt{011} as seen (it is inserted in set $L$, Algorithm~\ref{alg:NGramCPS}, l.\ref{alg:NGramCPS:line:insertL}) and we discard its first bit, updating the left $n$-gram to \texttt{111}. The local configuration becomes \texttt{111 [C1] 00?}.
    \item \textbf{Right $n$-gram update.} In order to deal with the unknown symbol \texttt{?}, we look among the previously seen right $n$-grams (contained in set $R$ in Algorithm~\ref{alg:NGramCPS}) the ones that start by \texttt{00}. For instance, let's assume it is \texttt{000} and \texttt{001}. Then we add both local contexts \texttt{111 [C1] 000} and \texttt{111 [C1] 001}, if not already in: (a) to our set of local configurations (Algorithm~\ref{alg:NGramCPS}, l.\ref{alg:NGramCPS:line:insertInConfSet}), and (b) to our set of configurations to visit (Algorithm~\ref{alg:NGramCPS}, l.\ref{alg:NGramCPS:line:insertInConfSetToVisit}) in order to repeat this procedure (or symmetrical when the machine moves left) on them.
\end{enumerate}

The algorithm systematically revisits all previously added local configurations, in case they contain a right/left $n$-gram that was newly met (Algorithm~\ref{alg:NGramCPS}, l.\ref{alg:NGramCPS:line:whileTrue}). Assuming a finite tape alphabet (which we always do in this work), the algorithm will eventually terminate since the number of possible local configurations is finite. In practice, one may add a limit on the number of iterations to avoid long computations.

\begin{theorem}[Correctness of \ngramcps]
    Consider a Turing machine using tape alphabet $\alphabet$ containing zero symbol $\alphabet_0$. If the \ngramcps decider returns `NON-HALT' when ran on the machine using some $n$-gram length parameter $n > 0$, then the machine does not halt from initial infinite tape containing all $\alphabet_0$.
\end{theorem}
\begin{proof}
    TODO. Point to Coq-BB5's NGramCPS.v. Consider using yforster's package for linking theorems to Coq.
\end{proof}



\subsubsection{Tape alphabet augmentations}\label{sec:n-gramCPS:augmentations}

The \ngramcps decider becomes particularly powerful for deciding 5-state 2-symbol Turing machines when augmenting the 2-symbol alphabet to store more information on the tape\tsm{We'll back this statement with numbers of decided machines in the result subsubsection.}. Two augmentations are used in the computerised proof:

\begin{enumerate}
    \item \textbf{Fixed-length history.} In this variant, tape symbols encode the current binary symbol on a cell as well as a fixed-length list of previously seen (state,binary symbol) pairs seen on the cell. For instance, if the non-augmented machine currently reads binary symbol \texttt{1} and the machine has previously visited the cell in state \textcolor{colorA}{A} reading symbol \texttt{0} and before that in state \textcolor{colorB}{B} reading symbol \texttt{1}, in the augmented machine, the cell will contain the augmented symbol ``\texttt{1, [(A,0),(B,1)]}''. If the history length is set to 2 and the machine was in state \textcolor{colorC}{C} when reading ``\texttt{1, [(A,0),(B,1)]}'' the cell will be updated to ``\texttt{0, [(C,1),(A,0)]}'', assuming the transition of the machine for reading a \texttt{1} in state \textcolor{colorC}{C} requires to write symbol \texttt{0}. The zero-symbol for this augmentation $\alphabet_0$ is ``\texttt{0, []}''. Furthermore, it is easy to verify that if the decider returns `NON-HALT' for a fixed-length augmented machine, then the non-augmented machine does not halt.
    \item \textbf{Least Recent Usage history (LRU).} In this variant, tape symbols encode the set of state-symbol pairs seen at that cell,
          in order of when it was seen last, the most recent first.  For instance, the non-augmented machine currently reads binary symbol \texttt{0} and the machine has previously visited the cell in state \textcolor{colorA}{D} reading symbol \texttt{1} and before that in state \textcolor{colorB}{D} reading symbol \texttt{0}, in the augmented machine, the cell will contain the augmented symbol ``\texttt{0, [(D,1),(D,0)]}''. If the machine was in state \textcolor{colorC}{D} when reading ``\texttt{0, [(D,1),(D,0)]}'' the cell will be updated to ``\texttt{0, [(D,0),(D,1)]}'', assuming the transition of the machine for reading a \texttt{0} in state \textcolor{colorC}{D} requires to write symbol \texttt{0}. The zero-symbol for this augmentation $\alphabet_0$ is also ``\texttt{0, []}''. Similarly to above, one can verify that if the decider returns `NON-HALT' for an LRU augmented machine, then the non-augmented machine does not halt.
\end{enumerate}

In the computerised proof, the \ngramcps decider is used (a) without augmentations, (b) with the fixed-length history and, (c) with the LRU augmentation, using the exact same implementation of the decider (as sketched in Algorithm~\ref{alg:NGramCPS}) just changing the used symbol alphabet and read/write behavior of the machine on the augmented alphabets.
\newpage
\newcommand{\leftngram}{left\xspace}
\newcommand{\rightngram}{right\xspace}
\newcommand{\middlesymbol}{middle\xspace}

\begin{algorithm}
    \caption{{\sc decider-NGramCPS}}\label{alg:NGramCPS}

    \begin{algorithmic}[1]
        \State{\textbf{Input:} a Turing machine `tm', the zero symbol of the alphabet $\alphabet_0$, the size of the n-grams $n > 0$.}
        \State{\textbf{Output:} `NON-HALT' if the decider detects that the machine doesn't halt and `UNKNOWN' otherwise.}

        \State $g_0 = (\alphabet_0)^n$ \Comment{The zero n-gram consists of $n$ zero symbols}
        \State $L = \{ g_0 \}$ \Comment{The seen left n-grams}
        \State $R = \{ g_0 \}$ \Comment{The seen right n-grams}
        \State $C =$ \{\{.\leftngram $=$ $g_0$, .\rightngram $=$ $g_0$, .state $=$ \textcolor{colorA}{A}, .\middlesymbol $=$ $\alphabet_0$ \}\} \Comment{The seen local configurations}
        \While{true}\label{alg:NGramCPS:line:whileTrue}
        \State $V = C$
        \State any\_updates $=$ false
        \While{$|V| \neq 0$}
        \State $c = V.\textbf{pop}()$
        \State $c' = c$
        \State $\{w,d,s\}$ $=$ tm(c.state, c.\middlesymbol) \Comment{Transition's write symbol, move direction, and next state}
        \State \If{$s$ is undefined} \Comment{Undefined transition is met, we cannot conclude}
        \State \textbf{return} UNKNOWN\label{alg:NGramCPS:line:unknown}
        \EndIf
        \State \If{$d$ is Right}
        \State Add $c.\text{\leftngram}$ to $L$ \label{alg:NGramCPS:line:insertL}
        \State Set $c'.\text{\leftngram}$ to the last $r-1$ symbols of $c.\text{\leftngram}$ followed by $w$
        \State Set $c'.\text{\middlesymbol}$ to the first symbol of $c.\text{\rightngram}$
        \For{each ngram $r\in R$ starting with the last $r-1$ symbols of $c.\text{\rightngram}$}
        \State Set $c'.\text{\rightngram}$ to $r$
        \If{$c'$ is not in $C$}
        \State \tabi Insert $c'$ in $C$ \label{alg:NGramCPS:line:insertInConfSet}
        \State \tabi Insert $c'$ in $V$ \label{alg:NGramCPS:line:insertInConfSetToVisit}
        \State \tabi any\_updates $=$ true
        \EndIf
        \EndFor
        \EndIf
        \State \If{$d$ is Left} \label{alg:NGramCPS:line:moveLeft}
        \State Add $c.\text{\rightngram}$ to $R$
        \State Set $c'.\text{\rightngram}$ to the first $r-1$ symbols of $c.\text{\rightngram}$ preceded by $w$
        \State Set $c'.\text{\middlesymbol}$ to the last symbol of $c.\text{\leftngram}$
        \For{each ngram $l \in L$ ending with the first $r-1$ symbols of $c.\text{\leftngram}$}
        \State Set $c'.\text{\leftngram}$ to $l$
        \If{$c'$ is not in $C$}
        \State \tabi Insert $c'$ in $C$
        \State \tabi Insert $c'$ in $V$
        \State \tabi any\_updates $=$ true
        \EndIf
        \EndFor
        \EndIf
        \EndWhile
        \State \If{\textbf{not} any\_updates}
        \State \textbf{return} NON-HALT\label{alg:NGramCPS:line:non-halt} \Comment{Set $C$ is closed, and does not include undefined transitions:\\ \tabi \tabi \tabi \tabi \tabi \tabi \tabi \tabi \tabi \tabi \tabi \space \space \space \space the machine doesn't halt}
        \EndIf

        \EndWhile
    \end{algorithmic}
\end{algorithm}

\subsubsection{Implementations and results}\label{sec:n-gramCPS:results}
TODO: requires Coq-BB5 extraction.